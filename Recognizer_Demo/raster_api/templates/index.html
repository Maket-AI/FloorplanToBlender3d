<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floor Plan Recognizer (api-raster)</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .upload-section {
            margin-bottom: 20px;
            padding: 20px;
            border: 2px dashed #ccc;
            border-radius: 5px;
            text-align: center;
        }
        .result-section {
            display: flex;
            flex-direction: column;
            width: 100%;
        }
        .image-container {
            width: 100%;
            margin-bottom: 20px;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            border: 1px solid #ddd;
            margin-top: 20px;
            background-color: white;
            overflow: hidden;
            background-image: 
                linear-gradient(to right, #eee 1px, transparent 1px),
                linear-gradient(to bottom, #eee 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #floorplan-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .toolbar button {
            padding: 5px 10px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
        }
        .toolbar button:hover {
            background-color: #e0e0e0;
        }
        .room-label {
            position: absolute;
            font-size: 12px;
            color: #333;
            pointer-events: none;
        }
        .dimension-label {
            position: absolute;
            font-size: 10px;
            color: #666;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 2px 4px;
            border-radius: 2px;
            pointer-events: none;
        }
        /* Loading spinner and progress bar */
        .loader-container {
            display: none;
            margin: 20px auto;
            text-align: center;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto 10px;
        }
        .progress-container {
            width: 100%;
            max-width: 400px;
            margin: 10px auto;
        }
        .progress-bar {
            height: 20px;
            background-color: #4CAF50;
            width: 0%;
            border-radius: 4px;
            transition: width 0.5s;
        }
        .timer {
            margin-top: 5px;
            font-size: 14px;
            color: #666;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Table styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Floor Plan Recognizer (api-raster)</h1>
        
        <div class="upload-section">
            <input type="file" id="fileInput" accept="image/*">
            <button onclick="processImage()">Process Floor Plan</button>
            <div id="loadingMessage">Processing...</div>
            <div id="errorMessage" class="error"></div>
        </div>
        
        <div class="loader-container" id="loader-container">
            <div class="loader"></div>
            <div class="progress-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="timer" id="timer">Processing: 0 seconds</div>
        </div>
        
        <div class="result-section">
            <div class="image-container">
                <h3>Original Image</h3>
                <img id="original-image" style="max-width: 100%; height: auto;" />
            </div>
            
            <div class="image-container">
                <h3>Floor Plan Visualization</h3>
                <div class="toolbar">
                    <button id="zoom-in">Zoom In</button>
                    <button id="zoom-out">Zoom Out</button>
                    <button id="reset-view">Reset View</button>
                </div>
                <div class="canvas-container">
                    <canvas id="floorplan-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        function renderFloorPlan(data) {
            currentData = data;
            
            // Resize the canvas to fit its container
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            redrawCanvas();
        }

        function processImage() {
            const fileInput = document.getElementById('fileInput');
            
            if (!fileInput.files || !fileInput.files[0]) {
                alert('Please select an image first');
                return;
            }
            
            // Show loading indicator and start progress
            document.getElementById('loadingMessage').style.display = 'block';
            document.getElementById('errorMessage').style.display = 'none';
            
            const loaderContainer = document.getElementById('loader-container');
            const progressBar = document.getElementById('progress-bar');
            const timerElement = document.getElementById('timer');
            
            loaderContainer.style.display = 'block';
            progressBar.style.width = '0%';
            
            // Start timing
            let seconds = 0;
            const timer = setInterval(() => {
                seconds++;
                timerElement.textContent = `Processing: ${seconds} seconds`;
                
                // Update progress bar - increases more quickly at first, then slows down
                let progress = 0;
                if (seconds < 3) {
                    progress = seconds * 20; // Fast initial progress
                } else if (seconds < 10) {
                    progress = 60 + (seconds - 3) * 3; // Slower after 3 seconds
                } else {
                    progress = 80 + Math.min((seconds - 10) * 0.5, 15); // Very slow after 10 seconds
                }
                progressBar.style.width = `${Math.min(progress, 95)}%`; // Never reach 100% until completion
            }, 1000);
            
            // Display the original image
            const originalImage = document.getElementById('original-image');
            originalImage.style.display = 'block';
            originalImage.src = URL.createObjectURL(fileInput.files[0]);
            
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            
            fetch('/process', {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || 'Error processing image');
                    });
                }
                return response.json();
            })
            .then(data => {
                // Hide loading indicator and complete progress
                document.getElementById('loadingMessage').style.display = 'none';
                clearInterval(timer);
                progressBar.style.width = '100%';
                
                setTimeout(() => {
                    loaderContainer.style.display = 'none';
                }, 500);
                
                // Check if the response contains an error
                if (data.error) {
                    document.getElementById('errorMessage').textContent = data.error;
                    document.getElementById('errorMessage').style.display = 'block';
                    return;
                }
                
                console.log("API Response:", data);
                
                // Transform the data to match the expected format
                const transformedData = {
                    walls: data.walls.map(wall => {
                        // Check if wall.position exists and has the expected structure
                        if (!wall.position || !Array.isArray(wall.position) || wall.position.length < 2) {
                            console.warn("Invalid wall data:", wall);
                            return { position: [0, 0] };
                        }
                        
                        return { position: wall.position };
                    }),
                    doors: (data.doors || []).map(door => {
                        // Check if door.position exists and has the expected structure
                        if (!door.position || !Array.isArray(door.position) || door.position.length < 2) {
                            console.warn("Invalid door data:", door);
                            return { position: [0, 0] };
                        }
                        
                        return { position: door.position };
                    }),
                    windows: (data.windows || []).map(window => {
                        // Check if window.position exists and has the expected structure
                        if (!window.position || !Array.isArray(window.position) || window.position.length < 2) {
                            console.warn("Invalid window data:", window);
                            return { position: [0, 0] };
                        }
                        
                        return { position: window.position };
                    }),
                    rooms: data.rooms
                };
                
                console.log("Transformed Data:", transformedData);
                
                // Render the canvas visualization
                renderFloorPlan(transformedData);
            })
            .catch(error => {
                // Hide loading indicator
                document.getElementById('loadingMessage').style.display = 'none';
                clearInterval(timer);
                loaderContainer.style.display = 'none';
                
                // Display error message
                document.getElementById('errorMessage').textContent = error.message;
                document.getElementById('errorMessage').style.display = 'block';
                console.error('Error:', error);
            });
        }

        // Canvas rendering functions
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let startX, startY;
        
        const canvas = document.getElementById('floorplan-canvas');
        const ctx = canvas.getContext('2d');
        
        // Zoom and pan controls
        document.getElementById('zoom-in').addEventListener('click', function() {
            scale *= 1.2;
            redrawCanvas();
        });
        
        document.getElementById('zoom-out').addEventListener('click', function() {
            scale *= 0.8;
            redrawCanvas();
        });
        
        document.getElementById('reset-view').addEventListener('click', function() {
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            redrawCanvas();
        });
        
        canvas.addEventListener('mousedown', function(e) {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', function(e) {
            if (isDragging) {
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                offsetX += dx;
                offsetY += dy;
                startX = e.clientX;
                startY = e.clientY;
                redrawCanvas();
            }
        });
        
        canvas.addEventListener('mouseup', function() {
            isDragging = false;
        });
        
        canvas.addEventListener('mouseleave', function() {
            isDragging = false;
        });
        
        // Function to find the nearest wall to a point
        function findNearestWall(point, walls) {
            if (!walls || !Array.isArray(walls) || walls.length === 0) {
                return null;
            }
            
            let minDist = Infinity;
            let nearestWall = null;
            
            walls.forEach(wall => {
                if (wall.position && wall.position.length >= 2) {
                    const start = wall.position[0];
                    const end = wall.position[1];
                    
                    const dist = pointToLineDistance(point, start, end);
                    
                    if (dist < minDist) {
                        minDist = dist;
                        nearestWall = wall;
                    }
                }
            });
            
            return nearestWall;
        }
        
        // Function to calculate distance from point to line segment
        function pointToLineDistance(point, lineStart, lineEnd) {
            const [x, y] = point;
            const [x1, y1] = lineStart;
            const [x2, y2] = lineEnd;
            
            const A = x - x1;
            const B = y - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = x - xx;
            const dy = y - yy;
            
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Function to align an item to a wall
        function alignToWall(item, wall) {
            const start = wall.position[0];
            const end = wall.position[1];
            
            // Calculate wall direction
            const dx = end[0] - start[0];
            const dy = end[1] - start[1];
            const length = Math.sqrt(dx * dx + dy * dy);
            
            // Normalize direction
            const nx = dx / length;
            const ny = dy / length;
            
            // Create the aligned item
            return {
                start: [item.position[0], item.position[1]],
                end: [item.position[0] + nx * 10, item.position[1] + ny * 10],
                normal: [nx, ny],
                wall: wall
            };
        }
        
        // Store the current data to enable redrawing
        let currentData = null;
        
        function redrawCanvas() {
            if (!currentData) return;
            
            const data = currentData;
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Find boundaries to calculate proper scaling
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            data.walls.forEach(wall => {
                const [start, end] = wall.position;
                minX = Math.min(minX, start[0], end[0]);
                minY = Math.min(minY, start[1], end[1]);
                maxX = Math.max(maxX, start[0], end[0]);
                maxY = Math.max(maxY, start[1], end[1]);
            });
            
            // Add padding
            const padding = 50;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            // Calculate scaling factor to fit the canvas
            const scaleX = canvas.width / width;
            const scaleY = canvas.height / height;
            const baseScale = Math.min(scaleX, scaleY);
            
            // Helper function to transform coordinates
            const transform = (x, y) => {
                const scaledX = (x - minX) * scale * baseScale;
                const scaledY = (y - minY) * scale * baseScale;
                return {
                    x: scaledX + offsetX,
                    y: scaledY + offsetY
                };
            };
            
            // Apply transformations
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale * baseScale, scale * baseScale);
            ctx.translate(-minX, -minY);
            
            // Draw rooms with light colors
            if (data.rooms) {
                data.rooms.forEach((room, index) => {
                    if (room.length >= 3) { // Need at least 3 points for a room
                        ctx.fillStyle = `hsla(${index * 30 % 360}, 70%, 85%, 0.3)`;
                        ctx.beginPath();
                        ctx.moveTo(room[0].x, room[0].y);
                        
                        for (let i = 1; i < room.length; i++) {
                            ctx.lineTo(room[i].x, room[i].y);
                        }
                        
                        ctx.closePath();
                        ctx.fill();
                        
                        // Add room label
                        const centerX = room.reduce((sum, point) => sum + point.x, 0) / room.length;
                        const centerY = room.reduce((sum, point) => sum + point.y, 0) / room.length;
                        
                        ctx.fillStyle = '#333';
                        ctx.font = `${12 / (scale * baseScale)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`Room ${index + 1}`, centerX, centerY);
                    }
                });
            }
            
            // Draw walls with improved styling
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3 / (scale * baseScale);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            data.walls.forEach(wall => {
                const [start, end] = wall.position;
                ctx.beginPath();
                ctx.moveTo(start[0], start[1]);
                ctx.lineTo(end[0], end[1]);
                ctx.stroke();
            });
            
            // Draw doors with simple lines directly on walls
            if (data.doors && data.doors.length > 0) {
                data.doors.forEach((door, index) => {
                    if (!door.position || door.position.length < 2) return;
                    
                    const [start, end] = door.position;
                    
                    // Draw door as simple white line
                    ctx.strokeStyle = '#FFFFFF';  // White color for doors
                    ctx.lineWidth = 3 / (scale * baseScale);
                    ctx.beginPath();
                    ctx.moveTo(start[0], start[1]);
                    ctx.lineTo(end[0], end[1]);
                    ctx.stroke();

                    // Add door ID
                    const centerX = (start[0] + end[0]) / 2;
                    const centerY = (start[1] + end[1]) / 2;
                    ctx.fillStyle = '#000000';
                    ctx.font = `${12 / (scale * baseScale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`D${index}`, centerX, centerY);

                    // Draw light blue bbox background (like in metadata_visualization.png)
                    const bboxWidth = 30;
                    const bboxHeight = 40;
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.2)';  // Very light blue with transparency
                    ctx.fillRect(centerX - bboxWidth/2, centerY - bboxHeight/2, bboxWidth, bboxHeight);
                });
            }
            
            // Draw windows with simple lines
            if (data.windows && data.windows.length > 0) {
                data.windows.forEach((window, index) => {
                    if (!window.position || window.position.length < 2) return;
                    
                    const [start, end] = window.position;
                    
                    // Draw window as simple blue line
                    ctx.strokeStyle = '#0000FF';  // Blue color for windows
                    ctx.lineWidth = 3 / (scale * baseScale);
                    ctx.beginPath();
                    ctx.moveTo(start[0], start[1]);
                    ctx.lineTo(end[0], end[1]);
                    ctx.stroke();

                    // Add window ID
                    const centerX = (start[0] + end[0]) / 2;
                    const centerY = (start[1] + end[1]) / 2;
                    ctx.fillStyle = '#000000';
                    ctx.font = `${12 / (scale * baseScale)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`W${index}`, centerX, centerY);
                });
            }
            
            // Draw measurements with improved styling
            const measurementOffset = 20 / (scale * baseScale);
            ctx.strokeStyle = '#666';
            ctx.fillStyle = '#333';
            ctx.font = `${10 / (scale * baseScale)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 1 / (scale * baseScale);
            
            data.walls.forEach(wall => {
                const [start, end] = wall.position;
                const dx = end[0] - start[0];
                const dy = end[1] - start[1];
                const length = Math.sqrt(dx * dx + dy * dy);
                
                if (length > 50) {  // Only show measurements for significant walls
                    const midX = (start[0] + end[0]) / 2;
                    const midY = (start[1] + end[1]) / 2;
                    const angle = Math.atan2(dy, dx);
                    
                    // Draw measurement line
                    ctx.save();
                    ctx.translate(midX, midY);
                    ctx.rotate(angle);
                    
                    // Draw tick marks
                    ctx.beginPath();
                    ctx.moveTo(-5, -measurementOffset);
                    ctx.lineTo(5, -measurementOffset);
                    ctx.stroke();
                    
                    // Draw measurement text
                    ctx.rotate(-angle);  // Rotate back for text
                    ctx.fillText(`${Math.round(length)} cm`, 0, -measurementOffset - 10);
                    
                    ctx.restore();
                }
            });
            
            ctx.restore();
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (currentData) {
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;
                redrawCanvas();
            }
        });
    </script>
</body>
</html> 