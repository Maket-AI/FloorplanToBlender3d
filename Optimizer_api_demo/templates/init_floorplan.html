<!DOCTYPE html>
<html lang="en">
<head>
    <!-- [Unchanged head content] -->
    <meta charset="UTF-8">
    <title>Floorplan Renovation Service</title>
    <style>
        canvas {
            border: 1px solid black;
            max-width: 100%;
            height: auto;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        /* Additional styles for better presentation */
        .container {
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
        }
        #selected-rooms {
            margin-top: 10px;
        }
        form {
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
        }
        /* Styles for dynamic elements */
        .opening-select {
            display: none;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Floorplan Renovation Service</h1>

        {% if error_message %}
        <p class="error-message">{{ error_message }}</p>
        {% endif %}

        {% if unnamed_rooms %}
        <h3>Add Names to Unnamed Rooms</h3>
        <canvas id="floorplan-canvas" style="display:none;"></canvas>
        <form id="add-names-form" method="POST" action="/add_room_names">
            {% for index in unnamed_rooms %}
            <div>
                <label for="room_name_{{ index }}">Room {{ index }} Name:</label>
                <select id="room_name_{{ index }}" name="room_name_{{ index }}" required>
                    <option value="" disabled selected>Select room type</option>
                    {% for room_type in all_room_types %}
                    <option value="{{ room_type }}">{{ room_type.replace('_', ' ').title() }}</option>
                    {% endfor %}
                    <option value="opening_room">Opening Room</option>
                </select>
                <input type="hidden" name="room_index_{{ index }}" value="{{ index }}">

                <!-- Additional select for opening_room -->
                <div id="opening_select_{{ index }}" class="opening-select">
                    <label for="opening_includes_{{ index }}">Opening contains:</label>
                    <select id="opening_includes_{{ index }}" name="opening_includes_{{ index }}">
                        <option value="" disabled selected>Select options</option>
                        <option value="entry,kitchen,dining_room,living_room">Entry, Kitchen, Dining Room, Living Room</option>
                        <option value="bedroom,closet,bathroom">Bedroom, Closet, Bathroom</option>
                        <option value="entry,kitchen,bedroom">Entry, Kitchen, Bedroom</option>
                    </select>
                </div>
            </div>
            <br>
            {% endfor %}
            <button type="submit">Save Names</button>
        </form>

        <script>
            const floorplanData = {{ floorplan_data | tojson }};
            const unnamedRooms = {{ unnamed_rooms | tojson }};
            const allRoomTypes = {{ all_room_types | tojson }};

            const canvas = document.getElementById('floorplan-canvas');
            const ctx = canvas.getContext('2d');

            // Calculate bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            floorplanData.areas.forEach(area => {
                area.poly.forEach(point => {
                    if (point.x < minX) minX = point.x;
                    if (point.y < minY) minY = point.y;
                    if (point.x > maxX) maxX = point.x;
                    if (point.y > maxY) maxY = point.y;
                });
            });

            // Add some padding to the bounding box
            const padding = 50;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            // Set higher canvas dimensions for better resolution
            const canvasWidth = 1600; // Adjust as needed
            const canvasHeight = 1200; // Adjust as needed
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Calculate scale to fit the content within the canvas
            const scaleX = canvas.width / (maxX - minX);
            const scaleY = canvas.height / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);

            // Apply scaling and translation
            ctx.scale(scale, scale);
            ctx.translate(-minX, -minY);

            // Function to get room color based on room type
            function getRoomColor(name, index) {
                const nightRooms = ['bedroom', 'bathroom', 'walk-in'];
                const nightRoomColors = ['#ADD8E6', '#87CEFA', '#4682B4']; // Shades of blue
                const dayRoomColors = ['#FFD700', '#FFA500', '#FF8C00']; // Shades of yellow/orange

                if (nightRooms.includes(name.toLowerCase())) {
                    return nightRoomColors[index % nightRoomColors.length];
                } else {
                    return dayRoomColors[index % dayRoomColors.length];
                }
            }

            function drawPolygon(points, color) {
                if (points.length === 0) return; // Do not draw if points are empty
                ctx.fillStyle = color || 'rgba(200, 200, 200, 0.5)'; // Use default color if none provided
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1 / scale;
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.slice(1).forEach(point => ctx.lineTo(point.x, point.y));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            function getCentroid(points) {
                let x = 0, y = 0;
                const numPoints = points.length;
                points.forEach(point => {
                    x += point.x;
                    y += point.y;
                });
                return { x: x / numPoints, y: y / numPoints };
            }

            // Function to get bounding rectangle dimensions
            function getBoundingRect(points) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                points.forEach(point => {
                    if (point.x < minX) minX = point.x;
                    if (point.y < minY) minY = point.y;
                    if (point.x > maxX) maxX = point.x;
                    if (point.y > maxY) maxY = point.y;
                });
                return { width: maxX - minX, height: maxY - minY };
            }

            function drawFloorplan() {
                ctx.clearRect(minX, minY, maxX - minX, maxY - minY);  // Clear the canvas

                floorplanData.areas.forEach((area, index) => {
                    const color = getRoomColor(area.name || 'room', index);
                    drawPolygon(area.poly, color);

                    // Calculate dimensions in meters
                    const rect = getBoundingRect(area.poly);
                    const widthMeters = (rect.width / 100).toFixed(2); // Convert cm to meters
                    const heightMeters = (rect.height / 100).toFixed(2); // Convert cm to meters

                    ctx.fillStyle = "#000";
                    ctx.font = `${40 / scale}px Arial`; // Increased font size for labels
                    if (area.poly.length > 0) {
                        const centroid = getCentroid(area.poly);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            `Room ${index}\n${widthMeters}m x ${heightMeters}m`,
                            centroid.x,
                            centroid.y
                        );
                    }
                });
            }

            drawFloorplan();

            // Adjust canvas display size using CSS for better resolution
            canvas.style.width = '800px'; // Adjust as needed
            canvas.style.height = '600px'; // Adjust as needed
            canvas.style.display = 'block'; // Show the canvas

            // JavaScript to handle dynamic display of opening options
            unnamedRooms.forEach(index => {
                const roomSelect = document.getElementById(`room_name_${index}`);
                const openingSelectDiv = document.getElementById(`opening_select_${index}`);

                roomSelect.addEventListener('change', function() {
                    if (this.value === 'opening_room') {
                        openingSelectDiv.style.display = 'block';
                    } else {
                        openingSelectDiv.style.display = 'none';
                    }
                });
            });
        </script>
        {% else %}
        <!-- The rest of your code remains the same -->
        <!-- Adjusted to include similar drawing functions -->
        <canvas id="floorplan-canvas" style="display:none;"></canvas>
        <h3>Select Room Indices to Renovate:</h3>
        <div id="selected-rooms"></div>
        <form id="renovation-form" method="POST" action="{{ url_for('process_option' + selected_option[-1]) }}">
            <input type="hidden" name="selected_indices" id="selected_indices" value="">

            {% if selected_option == 'option3' or selected_option == 'option4' %}
            <!-- Add rooms input block for Options 3 and 4 -->
            <div id="add_rooms_options">
                <label for="add_rooms">Add Rooms:</label>
                <input type="text" id="add_rooms" name="add_rooms" placeholder="e.g., bedroom, bathroom">
            </div>
            <br>
            {% endif %}

            <button type="submit">Submit</button>
        </form>

        <!-- Include your JavaScript for drawing and interaction here -->
        <script>
            const floorplanData = {{ floorplan_data | tojson }};
            const canvas = document.getElementById('floorplan-canvas');
            const ctx = canvas.getContext('2d');
            const selectedIndices = [];

            // Calculate bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            floorplanData.areas.forEach(area => {
                area.poly.forEach(point => {
                    if (point.x < minX) minX = point.x;
                    if (point.y < minY) minY = point.y;
                    if (point.x > maxX) maxX = point.x;
                    if (point.y > maxY) maxY = point.y;
                });
            });

            // Add some padding to the bounding box
            const padding = 50;
            minX -= padding;
            minY -= padding;
            maxX += padding;
            maxY += padding;

            // Set higher canvas dimensions for better resolution
            const canvasWidth = 1600; // Adjust as needed
            const canvasHeight = 1200; // Adjust as needed
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Calculate scale to fit the content within the canvas
            const scaleX = canvas.width / (maxX - minX);
            const scaleY = canvas.height / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);

            // Apply scaling and translation
            ctx.scale(scale, scale);
            ctx.translate(-minX, -minY);

            // Function to get room color based on room type
            function getRoomColor(name, index) {
                const nightRooms = ['bedroom', 'bathroom', 'walk-in'];
                const nightRoomColors = ['#ADD8E6', '#87CEFA', '#4682B4']; // Shades of blue
                const dayRoomColors = ['#FFD700', '#FFA500', '#FF8C00']; // Shades of yellow/orange

                if (nightRooms.includes(name.toLowerCase())) {
                    return nightRoomColors[index % nightRoomColors.length];
                } else {
                    return dayRoomColors[index % dayRoomColors.length];
                }
            }

            function drawPolygon(points, color) {
                if (points.length === 0) return; // Do not draw if points are empty
                ctx.fillStyle = color;
                ctx.strokeStyle = '#000'; // Outline color
                ctx.lineWidth = 1 / scale; // Adjust line width based on scale
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                points.slice(1).forEach(point => ctx.lineTo(point.x, point.y));
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }

            function getCentroid(points) {
                let x = 0, y = 0;
                const numPoints = points.length;
                points.forEach(point => {
                    x += point.x;
                    y += point.y;
                });
                return { x: x / numPoints, y: y / numPoints };
            }

            // Function to get bounding rectangle dimensions
            function getBoundingRect(points) {
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                points.forEach(point => {
                    if (point.x < minX) minX = point.x;
                    if (point.y < minY) minY = point.y;
                    if (point.x > maxX) maxX = point.x;
                    if (point.y > maxY) maxY = point.y;
                });
                return { width: maxX - minX, height: maxY - minY };
            }

            function drawFloorplan() {
                ctx.clearRect(minX, minY, maxX - minX, maxY - minY);  // Clear the canvas

                floorplanData.areas.forEach((area, index) => {
                    const color = getRoomColor(area.name || 'room', index);
                    drawPolygon(area.poly, color);

                    // Calculate dimensions in meters
                    const rect = getBoundingRect(area.poly);
                    const widthMeters = (rect.width / 100).toFixed(2); // Convert cm to meters
                    const heightMeters = (rect.height / 100).toFixed(2); // Convert cm to meters

                    ctx.fillStyle = "#000";
                    ctx.font = `${40 / scale}px Arial`; // Increased font size for labels
                    if (area.poly.length > 0) {
                        const centroid = getCentroid(area.poly);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            `${area.name || 'Room'} (${index})\n${widthMeters}m x ${heightMeters}m`,
                            centroid.x,
                            centroid.y
                        );
                    }
                });
            }

            function handleCanvasClick(event) {
                const rect = canvas.getBoundingClientRect();
                const x = (event.clientX - rect.left) * (canvas.width / canvas.offsetWidth) / scale + minX;
                const y = (event.clientY - rect.top) * (canvas.height / canvas.offsetHeight) / scale + minY;

                floorplanData.areas.forEach((area, index) => {
                    const path = new Path2D();
                    path.moveTo(area.poly[0].x, area.poly[0].y);
                    area.poly.slice(1).forEach(point => path.lineTo(point.x, point.y));
                    path.closePath();

                    if (ctx.isPointInPath(path, x, y)) {
                        const selectedIndex = selectedIndices.indexOf(index);
                        if (selectedIndex === -1) {
                            selectedIndices.push(index);
                            drawPolygon(area.poly, 'rgba(0, 255, 0, 0.5)'); // Highlight selected area
                        } else {
                            selectedIndices.splice(selectedIndex, 1);
                            const color = getRoomColor(area.name || 'room', index);
                            drawPolygon(area.poly, color); // Re-draw the original area color
                        }
                    }
                });

                // Re-draw labels
                floorplanData.areas.forEach((area, index) => {
                    ctx.fillStyle = "#000";
                    ctx.font = `${40 / scale}px Arial`;
                    if (area.poly.length > 0) {
                        const centroid = getCentroid(area.poly);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        const rect = getBoundingRect(area.poly);
                        const widthMeters = (rect.width / 100).toFixed(2);
                        const heightMeters = (rect.height / 100).toFixed(2);
                        ctx.fillText(
                            `${area.name || 'Room'} (${index})\n${widthMeters}m x ${heightMeters}m`,
                            centroid.x,
                            centroid.y
                        );
                    }
                });

                document.getElementById('selected_indices').value = JSON.stringify(selectedIndices);
                updateSelectedRoomsDisplay();
            }

            function updateSelectedRoomsDisplay() {
                const selectedRoomsDiv = document.getElementById('selected-rooms');
                selectedRoomsDiv.innerHTML = `<p>Selected Room Indices: ${selectedIndices.join(', ')}</p>`;
            }

            canvas.addEventListener('click', handleCanvasClick);

            drawFloorplan();

            // Adjust canvas display size using CSS for better resolution
            canvas.style.width = '800px'; // Adjust as needed
            canvas.style.height = '600px'; // Adjust as needed
            canvas.style.display = 'block'; // Show the canvas
        </script>
        {% endif %}
    </div>
</body>
</html>
