<!doctype html>
<html lang="en">
<head>
    <!-- Head Content -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Final Floorplan</title>
    <style>
        /* CSS Styles */
        canvas {
            border: 1px solid black;
            max-width: 100%;
            height: auto;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        .renovate-button {
            font-size: 20px;
            background-color: green;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .renovate-button:hover {
            background-color: darkgreen;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Floorplan Renovation Service</h1>
        <button onclick="window.location.href='/'" class="renovate-button">Upload Another Floorplan</button>

        <p id="status">Please wait while processing...</p> <!-- Status message area -->

        {% if error_message %}
        <p class="error-message">{{ error_message }}</p>
        {% endif %}

        <canvas id="floorplan-canvas" style="display:none;"></canvas> <!-- Initially hidden canvas for drawing -->

        <script>
            // JavaScript Code
            const jobId = "{{ job_id }}";  // Pass the job_id to JavaScript
            const originalFloorplanData = {{ original_floorplan_data | tojson }}; // Original floorplan data

            function checkJobStatus() {
                fetch(`/check_status/${jobId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'complete') {
                            // Job completed, update the page with results
                            document.getElementById('status').innerText = 'Processing complete';
                            displayResult(data.result);  // Function to display the result
                        } else if (data.status === 'in progress') {
                            // Job still in progress, keep polling
                            setTimeout(checkJobStatus, 5000);  // Retry after 5 seconds
                        } else {
                            document.getElementById('status').innerText = 'Still in progress, reloading the page...';
                            setTimeout(function() {
                                location.reload(); // Reload the page after 5 seconds
                            }, 5000); // Wait for 5 seconds before reloading
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching job status:', error);
                        document.getElementById('status').innerText = 'Error checking job status. Retrying...';
                        setTimeout(checkJobStatus, 5000);  // Retry after 5 seconds in case of error
                    });
            }

            function displayResult(result) {
                // Show the canvas element
                const canvas = document.getElementById('floorplan-canvas');
                canvas.style.display = 'block';
                const ctx = canvas.getContext('2d');

                // Parse result and update the canvas
                const resultData = JSON.parse(result);
                const areas = resultData.areas; // Result floorplan areas
                const originalAreas = originalFloorplanData.areas; // Original floorplan areas

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                // Find min and max values from both original and result data
                [originalAreas, areas].forEach(areaList => {
                    areaList.forEach(area => {
                        area.poly.forEach(point => {
                            if (point.x < minX) minX = point.x;
                            if (point.y < minY) minY = point.y;
                            if (point.x > maxX) maxX = point.x;
                            if (point.y > maxY) maxY = point.y;
                        });
                    });
                });

                // Add padding
                const padding = 50;
                minX -= padding;
                minY -= padding;
                maxX += padding;
                maxY += padding;

                // Set higher canvas dimensions for better resolution
                const canvasWidth = 1600; // Increased canvas width
                const canvasHeight = 1200; // Increased canvas height
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Calculate scale to fit the content within the canvas
                const scaleX = canvas.width / (maxX - minX);
                const scaleY = canvas.height / (maxY - minY);
                const scale = Math.min(scaleX, scaleY);

                // Apply scaling and translation
                ctx.scale(scale, scale);
                ctx.translate(-minX, -minY);

                // Function to get room color based on room type
                function getRoomColor(name, index) {
                    const nightRooms = ['bedroom', 'bathroom', 'walk-in'];
                    const nightRoomColors = ['#ADD8E6', '#87CEFA', '#4682B4']; // shades of blue
                    const dayRoomColors = ['#FFD700', '#FFA500', '#FF8C00']; // shades of yellow/orange

                    if (nightRooms.includes(name.toLowerCase())) {
                        return nightRoomColors[index % nightRoomColors.length];
                    } else {
                        return dayRoomColors[index % dayRoomColors.length];
                    }
                }

                // Function to convert hex color to rgba with alpha
                function hexToRGBA(hex, alpha) {
                    var r = parseInt(hex.slice(1,3), 16);
                    var g = parseInt(hex.slice(3,5), 16);
                    var b = parseInt(hex.slice(5,7), 16);

                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }

                function drawPolygon(points, color, fillAlpha = 1, strokeColor = '#000', lineWidth = 1 / scale) {
                    if (points.length === 0) return; // Do not draw if points are empty
                    ctx.fillStyle = hexToRGBA(color, fillAlpha); // Set fill color with transparency
                    ctx.strokeStyle = strokeColor; // Outline color
                    ctx.lineWidth = lineWidth; // Line width
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.slice(1).forEach(point => ctx.lineTo(point.x, point.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                function getCentroid(points) {
                    let x = 0, y = 0;
                    const numPoints = points.length;
                    points.forEach(point => {
                        x += point.x;
                        y += point.y;
                    });
                    return { x: x / numPoints, y: y / numPoints };
                }

                function getBoundingRectangle(points) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    points.forEach(point => {
                        if (point.x < minX) minX = point.x;
                        if (point.y < minY) minY = point.y;
                        if (point.x > maxX) maxX = point.x;
                        if (point.y > maxY) maxY = point.y;
                    });
                    return { minX, minY, maxX, maxY };
                }

                function drawFloorplan() {
                    ctx.clearRect(minX, minY, maxX - minX, maxY - minY); // Clear canvas before drawing

                    // Draw the original floorplan boundaries in a light color
                    originalAreas.forEach((area) => {
                        const color = '#CCCCCC'; // Light grey color for original boundaries
                        drawPolygon(area.poly, color, 0.0, '#AAAAAA', 1 / scale); // No fill, light grey stroke
                    });

                    // Draw the result floorplan in stronger colors
                    areas.forEach((area, index) => {
                        let color;
                        if (area.name.toLowerCase() === 'corridor') {
                            color = '#cfcfcf'; // Grey color for corridors
                        } else {
                            color = getRoomColor(area.name, index);
                        }
                        drawPolygon(area.poly, color, 0.6); // Semi-transparent fill
                        ctx.fillStyle = "#000";
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        if (area.poly.length > 0) {
                            const centroid = getCentroid(area.poly);
                            const boundingRect = getBoundingRectangle(area.poly);
                            const widthMeters = ((boundingRect.maxX - boundingRect.minX) / 100).toFixed(2); // Convert cm to meters
                            const heightMeters = ((boundingRect.maxY - boundingRect.minY) / 100).toFixed(2);

                            // Only draw labels if the room is not a corridor
                            if (area.name.toLowerCase() !== 'corridor') {
                                // Draw room name
                                ctx.font = `${40 / scale}px Arial`; // Font size for room name
                                ctx.fillText(`${area.name}`, centroid.x, centroid.y - (10 / scale));

                                // Draw width x height in smaller font
                                ctx.font = `${30 / scale}px Arial`; // Smaller font size
                                ctx.fillText(`${widthMeters} x ${heightMeters} m`, centroid.x, centroid.y + (20 / scale));
                            }
                        }
                    });
                }

                drawFloorplan();

                // Adjust canvas display size using CSS for better resolution
                canvas.style.width = '800px'; // Adjust as needed
                canvas.style.height = '600px'; // Adjust as needed
            }

            // Initial status check
            checkJobStatus();
        </script>
    </div>
</body>
</html>
