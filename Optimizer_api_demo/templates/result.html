<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Final Floorplan</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .canvas-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 20px;
            justify-content: center;
        }
        canvas {
            border: 1px solid black;
            max-width: 100%;
            height: auto;
        }
        .remote-image {
            max-width: 600px;
            max-height: 450px;
            border: 1px solid #ddd;
            padding: 5px;
            box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.1);
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        .renovate-button {
            font-size: 20px;
            background-color: green;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        .renovate-button:hover {
            background-color: darkgreen;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Floorplan Renovation Service</h1>
        <button onclick="window.location.href='/'" class="renovate-button">Upload Another Floorplan</button>

        <p id="status">Please wait while processing...</p>

        {% if error_message %}
        <p class="error-message">{{ error_message }}</p>
        {% endif %}

        <div class="canvas-container">
            <canvas id="floorplan-canvas" style="display:none;"></canvas>
            <img id="remote-image" src="" alt="Generated Floorplan Image" class="remote-image" style="display:none;">
        </div>

        <script>
            const jobId = "{{ job_id }}";
            const originalFloorplanData = {{ original_floorplan_data | tojson }};

            function checkJobStatus() {
                fetch(`/check_status/${jobId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'complete') {
                            document.getElementById('status').innerText = 'Processing complete';
                            displayResult(data.result);
                        } else if (data.status === 'in progress') {
                            setTimeout(checkJobStatus, 5000);
                        } else {
                            document.getElementById('status').innerText = 'Still in progress, reloading the page...';
                            setTimeout(() => location.reload(), 5000);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching job status:', error);
                        document.getElementById('status').innerText = 'Error checking job status. Retrying...';
                        setTimeout(checkJobStatus, 5000);
                    });
            }

            function displayResult(result) {
                const resultData = JSON.parse(result);
                const areas = resultData.areas;
                const remoteImageUrl = resultData.remote_image_url;

                if (remoteImageUrl) {
                    const remoteImage = document.getElementById('remote-image');
                    remoteImage.src = remoteImageUrl;
                    remoteImage.style.display = 'block';
                }

                const canvas = document.getElementById('floorplan-canvas');
                canvas.style.display = 'block';
                const ctx = canvas.getContext('2d');

                const originalAreas = originalFloorplanData.areas;
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                [originalAreas, areas].forEach(areaList => {
                    areaList.forEach(area => {
                        area.poly.forEach(point => {
                            if (point.x < minX) minX = point.x;
                            if (point.y < minY) minY = point.y;
                            if (point.x > maxX) maxX = point.x;
                            if (point.y > maxY) maxY = point.y;
                        });
                    });
                });

                const padding = 50;
                minX -= padding;
                minY -= padding;
                maxX += padding;
                maxY += padding;

                const canvasWidth = 800;
                const canvasHeight = 600;
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                const scaleX = canvas.width / (maxX - minX);
                const scaleY = canvas.height / (maxY - minY);
                const scale = Math.min(scaleX, scaleY);

                ctx.scale(scale, scale);
                ctx.translate(-minX, -minY);

                function getRoomColor(name, index) {
                    const nightRooms = ['bedroom', 'bathroom', 'walk-in'];
                    const nightRoomColors = ['#ADD8E6', '#87CEFA', '#4682B4'];
                    const dayRoomColors = ['#FFD700', '#FFA500', '#FF8C00'];
                    return nightRooms.includes(name.toLowerCase()) ? nightRoomColors[index % nightRoomColors.length] : dayRoomColors[index % dayRoomColors.length];
                }

                function hexToRGBA(hex, alpha) {
                    const r = parseInt(hex.slice(1,3), 16);
                    const g = parseInt(hex.slice(3,5), 16);
                    const b = parseInt(hex.slice(5,7), 16);
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }

                function drawPolygon(points, color, fillAlpha = 1, strokeColor = '#000', lineWidth = 1 / scale) {
                    if (points.length === 0) return;
                    ctx.fillStyle = hexToRGBA(color, fillAlpha);
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    points.slice(1).forEach(point => ctx.lineTo(point.x, point.y));
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                function getCentroid(points) {
                    let x = 0, y = 0;
                    points.forEach(point => {
                        x += point.x;
                        y += point.y;
                    });
                    return { x: x / points.length, y: y / points.length };
                }

                function getBoundingRectangle(points) {
                    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                    points.forEach(point => {
                        if (point.x < minX) minX = point.x;
                        if (point.y < minY) minY = point.y;
                        if (point.x > maxX) maxX = point.x;
                        if (point.y > maxY) maxY = point.y;
                    });
                    return { minX, minY, maxX, maxY };
                }

                function drawFloorplan() {
                    ctx.clearRect(minX, minY, maxX - minX, maxY - minY);

                    originalAreas.forEach((area) => {
                        const color = '#CCCCCC';
                        drawPolygon(area.poly, color, 0.0, '#AAAAAA', 1 / scale);
                    });

                    areas.forEach((area, index) => {
                        const color = area.name.toLowerCase() === 'corridor' ? '#cfcfcf' : getRoomColor(area.name, index);
                        drawPolygon(area.poly, color, 0.6);
                        ctx.fillStyle = "#000";
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        if (area.poly.length > 0) {
                            const centroid = getCentroid(area.poly);
                            const boundingRect = getBoundingRectangle(area.poly);
                            const widthMeters = ((boundingRect.maxX - boundingRect.minX) / 100).toFixed(2);
                            const heightMeters = ((boundingRect.maxY - boundingRect.minY) / 100).toFixed(2);

                            if (area.name.toLowerCase() !== 'corridor') {
                                const labelFontSize = 20 / scale;  // Adjusted font size based on scale
                                const sizeFontSize = 15 / scale;  // Adjusted size label font
                                ctx.font = `${labelFontSize}px Arial`;
                                ctx.fillText(`${area.name}`, centroid.x, centroid.y - (10 / scale));

                                ctx.font = `${sizeFontSize}px Arial`;
                                ctx.fillText(`${widthMeters} x ${heightMeters} m`, centroid.x, centroid.y + (20 / scale));
                            }
                        }
                    });
                }

                drawFloorplan();
                canvas.style.width = '600px';
                canvas.style.height = '450px';
            }

            checkJobStatus();
        </script>
    </div>
</body>
</html>
